{"ast":null,"code":"var _s = $RefreshSig$();\nimport React from 'react';\nimport { useMap } from 'react-leaflet'; // Import Leaflet context\nimport L from 'leaflet'; // Required for Leaflet functionality\nimport { hexbin } from 'd3-hexbin'; // Hexbin import\nimport * as d3 from 'd3'; // D3 for data processing\n\nexport const BubbleMap = ({\n  data\n}) => {\n  _s();\n  const map = useMap(); // Get the Leaflet map instance\n\n  // Create color scale for HRV values\n  const colorScale = d3.scaleLinear().domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]).range(['lightblue', 'blue', 'darkblue']); // Color range\n\n  // Hexbin generator\n  const hexbinGenerator = hexbin().radius(20) // Hexagon radius\n  .x(d => d[0]) // Longitude\n  .y(d => d[1]); // Latitude\n\n  // Prepare point array for hexbin\n  const points = data.map(feat => [feat.LocationCoordinates[1], feat.LocationCoordinates[0]]); // [lng, lat]\n\n  // Generate hexagons based on point coordinates\n  const bins = hexbinGenerator(points); // Create bins based on hexbin algorithm\n\n  // Create Leaflet layer for hexagons\n  const hexbinLayer = L.layerGroup().addTo(map); // Create group for hexagons\n\n  // Create hexagons for each bin\n  bins.forEach(bin => {\n    const avgHRV = d3.mean(bin.map(d => data.find(feature => feature.LocationCoordinates[1] === d[0] && feature.LocationCoordinates[0] === d[1]).HRV));\n\n    // Create hexagon vertices\n    const hexagon = generateHexagon(bin.x, bin.y, 20); // Use bin center\n\n    // Add hexagon to Leaflet map\n    L.polygon(hexagon, {\n      color: colorScale(avgHRV),\n      // Set color based on average HRV\n      fillColor: colorScale(avgHRV),\n      // Fill color based on average HRV\n      fillOpacity: 0.6,\n      weight: 1\n    }).addTo(hexbinLayer); // Add to hexbin layer group\n  });\n  return null; // No direct rendering from this component\n};\n\n// Function to generate hexagon vertices based on center coordinates and radius\n_s(BubbleMap, \"cX187cvZ2hODbkaiLn05gMk1sCM=\", false, function () {\n  return [useMap];\n});\n_c = BubbleMap;\nconst generateHexagon = (lat, lng, radius) => {\n  const angle = Math.PI / 3; // 60 degrees\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    points.push([lat + radius * Math.sin(angle * i),\n    // Latitude adjustment\n    lng + radius * Math.cos(angle * i) // Longitude adjustment\n    ]);\n  }\n  return points; // Returns vertices for hexagon\n};\nvar _c;\n$RefreshReg$(_c, \"BubbleMap\");","map":{"version":3,"names":["React","useMap","L","hexbin","d3","BubbleMap","data","_s","map","colorScale","scaleLinear","domain","min","d","HRV","mean","max","range","hexbinGenerator","radius","x","y","points","feat","LocationCoordinates","bins","hexbinLayer","layerGroup","addTo","forEach","bin","avgHRV","find","feature","hexagon","generateHexagon","polygon","color","fillColor","fillOpacity","weight","_c","lat","lng","angle","Math","PI","i","push","sin","cos","$RefreshReg$"],"sources":["/Users/fmparantean/Desktop/mixvisual 3/src/BubbleMap/index.js"],"sourcesContent":["import React from 'react';\nimport { useMap } from 'react-leaflet'; // Import Leaflet context\nimport L from 'leaflet'; // Required for Leaflet functionality\nimport { hexbin } from 'd3-hexbin'; // Hexbin import\nimport * as d3 from 'd3'; // D3 for data processing\n\nexport const BubbleMap = ({ data }) => {\n    const map = useMap(); // Get the Leaflet map instance\n\n    // Create color scale for HRV values\n    const colorScale = d3.scaleLinear()\n        .domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)])\n        .range(['lightblue', 'blue', 'darkblue']); // Color range\n\n    // Hexbin generator\n    const hexbinGenerator = hexbin()\n        .radius(20)  // Hexagon radius\n        .x(d => d[0]) // Longitude\n        .y(d => d[1]); // Latitude\n\n    // Prepare point array for hexbin\n    const points = data.map(feat => [feat.LocationCoordinates[1], feat.LocationCoordinates[0]]); // [lng, lat]\n\n    // Generate hexagons based on point coordinates\n    const bins = hexbinGenerator(points); // Create bins based on hexbin algorithm\n\n    // Create Leaflet layer for hexagons\n    const hexbinLayer = L.layerGroup().addTo(map); // Create group for hexagons\n\n    // Create hexagons for each bin\n    bins.forEach(bin => {\n        const avgHRV = d3.mean(bin.map(d => \n            data.find(feature => \n                feature.LocationCoordinates[1] === d[0] && \n                feature.LocationCoordinates[0] === d[1]).HRV\n        ));\n\n        // Create hexagon vertices\n        const hexagon = generateHexagon(bin.x, bin.y, 20); // Use bin center\n\n        // Add hexagon to Leaflet map\n        L.polygon(hexagon, {\n            color: colorScale(avgHRV), // Set color based on average HRV\n            fillColor: colorScale(avgHRV), // Fill color based on average HRV\n            fillOpacity: 0.6,\n            weight: 1,\n        }).addTo(hexbinLayer); // Add to hexbin layer group\n    });\n\n    return null; // No direct rendering from this component\n};\n\n// Function to generate hexagon vertices based on center coordinates and radius\nconst generateHexagon = (lat, lng, radius) => {\n    const angle = (Math.PI / 3); // 60 degrees\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n        points.push([\n            lat + (radius * Math.sin(angle * i)), // Latitude adjustment\n            lng + (radius * Math.cos(angle * i))  // Longitude adjustment\n        ]);\n    }\n    return points; // Returns vertices for hexagon\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}