{"ast":null,"code":"var _s = $RefreshSig$();\n// UpdatingHexBin.js\nimport { useMap } from 'react-leaflet';\nimport { useEffect } from 'react';\nimport L from 'leaflet';\nimport { hexbin } from 'd3-hexbin'; // Correct import for hexbin\nimport * as d3 from 'd3'; // Import D3 utilities\n\nconst UpdatingHexBin = ({\n  data\n}) => {\n  _s();\n  const map = useMap();\n  useEffect(() => {\n    const hexbinLayer = L.layerGroup().addTo(map); // Create a layer group for hexagons\n\n    // Create the hexbin generator\n    const hexbinGenerator = hexbin().radius(20) // Set the radius suitable for your data distribution\n    .x(d => d[0]) // Accessor for latitude (Y)\n    .y(d => d[1]); // Accessor for longitude (X)\n\n    // Prepare points for hexbin generator\n    const points = data.map(feat => [feat.LocationCoordinates[1], feat.LocationCoordinates[0]]); // [lng, lat]\n\n    // Generate hexagons based on the points\n    const bins = hexbinGenerator(points);\n\n    // Set up color scale for HRV values\n    const hrvExtent = d3.extent(data, d => d.HRV); // Get minimum and maximum HRV values\n    const colorScale = d3.scaleSequential(d3.interpolateBlues).domain(hrvExtent); // Color scale\n\n    // Loop through each bin to create polygons (hexagons)\n    bins.forEach(bin => {\n      const avgHRV = d3.mean(bin.map(d => data.find(feature => feature.LocationCoordinates[1] === d[0] && feature.LocationCoordinates[0] === d[1]).HRV));\n      const latlngs = bin.map(d => [d[1], d[0]]); // Convert to [lat, lng] format\n\n      // Create a polygon for this hexagon\n      L.polygon(latlngs, {\n        color: colorScale(avgHRV),\n        // Exterior stroke color based on average HRV\n        fillColor: colorScale(avgHRV),\n        // Fill color based on average HRV\n        fillOpacity: 0.6,\n        weight: 1\n      }).addTo(hexbinLayer); // Add hexagon to the hexbin layer\n    });\n    return () => {\n      if (map.hasLayer(hexbinLayer)) {\n        map.removeLayer(hexbinLayer); // Cleanup on component unmount\n      }\n    };\n  }, [data, map]);\n  return null; // No direct rendering\n};\n_s(UpdatingHexBin, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c = UpdatingHexBin;\nexport default UpdatingHexBin;\nvar _c;\n$RefreshReg$(_c, \"UpdatingHexBin\");","map":{"version":3,"names":["useMap","useEffect","L","hexbin","d3","UpdatingHexBin","data","_s","map","hexbinLayer","layerGroup","addTo","hexbinGenerator","radius","x","d","y","points","feat","LocationCoordinates","bins","hrvExtent","extent","HRV","colorScale","scaleSequential","interpolateBlues","domain","forEach","bin","avgHRV","mean","find","feature","latlngs","polygon","color","fillColor","fillOpacity","weight","hasLayer","removeLayer","_c","$RefreshReg$"],"sources":["/Users/fmparantean/Desktop/mixvisual 3/src/useWorldAtlas.js"],"sourcesContent":["// UpdatingHexBin.js\nimport { useMap } from 'react-leaflet';\nimport { useEffect } from 'react';\nimport L from 'leaflet';\nimport { hexbin } from 'd3-hexbin'; // Correct import for hexbin\nimport * as d3 from 'd3'; // Import D3 utilities\n\nconst UpdatingHexBin = ({ data }) => {\n    const map = useMap();\n\n    useEffect(() => {\n        const hexbinLayer = L.layerGroup().addTo(map); // Create a layer group for hexagons\n\n        // Create the hexbin generator\n        const hexbinGenerator = hexbin()\n            .radius(20) // Set the radius suitable for your data distribution\n            .x(d => d[0]) // Accessor for latitude (Y)\n            .y(d => d[1]); // Accessor for longitude (X)\n\n        // Prepare points for hexbin generator\n        const points = data.map(feat => [feat.LocationCoordinates[1], feat.LocationCoordinates[0]]); // [lng, lat]\n\n        // Generate hexagons based on the points\n        const bins = hexbinGenerator(points);\n\n        // Set up color scale for HRV values\n        const hrvExtent = d3.extent(data, d => d.HRV); // Get minimum and maximum HRV values\n        const colorScale = d3.scaleSequential(d3.interpolateBlues).domain(hrvExtent); // Color scale\n\n        // Loop through each bin to create polygons (hexagons)\n        bins.forEach(bin => {\n            const avgHRV = d3.mean(bin.map(d => data.find(feature => \n                feature.LocationCoordinates[1] === d[0] && feature.LocationCoordinates[0] === d[1]).HRV\n            ));\n            const latlngs = bin.map(d => [d[1], d[0]]); // Convert to [lat, lng] format\n\n            // Create a polygon for this hexagon\n            L.polygon(latlngs, {\n                color: colorScale(avgHRV), // Exterior stroke color based on average HRV\n                fillColor: colorScale(avgHRV), // Fill color based on average HRV\n                fillOpacity: 0.6,\n                weight: 1\n            }).addTo(hexbinLayer); // Add hexagon to the hexbin layer\n        });\n\n        return () => {\n            if (map.hasLayer(hexbinLayer)) {\n                map.removeLayer(hexbinLayer); // Cleanup on component unmount\n            }\n        };\n    }, [data, map]);\n\n    return null; // No direct rendering\n};\n\nexport default UpdatingHexBin;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}