{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect } from 'react';\nimport { useMap } from 'react-leaflet'; // Use Leaflet map context\nimport L from 'leaflet'; // Import Leaflet\nimport { hexbin } from 'd3-hexbin'; // Import D3 hexbin for creating hexagons\nimport * as d3 from 'd3'; // Import D3 utilities\n\nexport const BubbleMap = ({\n  data\n}) => {\n  _s();\n  const map = useMap(); // Access the Leaflet map instance\n\n  useEffect(() => {\n    // Create hexbin generator\n    const hexbinGenerator = hexbin().radius(20) // Radius for the hexbins\n    .x(d => d[0]) // Longitude accessor\n    .y(d => d[1]); // Latitude accessor\n\n    // Prepare points for hexbin\n    const points = data.map(feat => feat.coords);\n\n    // Log the processed points\n    console.log(\"Processed Points:\", points);\n\n    // Generate hexagon bins\n    const bins = hexbinGenerator(points);\n\n    // Log the generated bins\n    console.log(\"Hex Bins:\", bins);\n\n    // Create color scale for HRV values\n    const colorScale = d3.scaleLinear().domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]).range(['lightblue', 'blue', 'darkblue']);\n\n    // Create layer group for hexagons\n    const hexbinLayer = L.layerGroup().addTo(map);\n\n    // Create hexagons for each bin\n    bins.forEach(bin => {\n      const avgHRV = d3.mean(bin.map(d => data.find(feature => feature.coords[0] === d[0] && feature.coords[1] === d[1]).HRV));\n\n      // Log average HRV for each bin\n      console.log(\"Average HRV for Bin:\", avgHRV);\n\n      // Generate hexagon vertices\n      const hexCoords = generateHexagon(bin.x, bin.y, 20); // Use the center of the bin\n\n      // Create and add hexagon to the Leaflet map\n      L.polygon(hexCoords, {\n        color: colorScale(avgHRV),\n        // Set color based on average HRV\n        fillColor: colorScale(avgHRV),\n        fillOpacity: 0.6,\n        weight: 1\n      }).addTo(hexbinLayer);\n    });\n    return () => {\n      // Cleanup the hexbin layer on unmount\n      if (map.hasLayer(hexbinLayer)) {\n        map.removeLayer(hexbinLayer);\n      }\n    };\n  }, [data, map]); // Depend on data and map changes\n\n  return null; // No direct rendering\n};\n\n// Function to generate hexagon vertices based on center coordinates and radius\n_s(BubbleMap, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c = BubbleMap;\nconst generateHexagon = (lat, lng, radius) => {\n  const angle = Math.PI / 3; // 60 degrees\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    points.push([lat + radius * Math.sin(angle * i),\n    // Latitude adjustment\n    lng + radius * Math.cos(angle * i) // Longitude adjustment\n    ]);\n  }\n  return points; // Return vertices of the hexagon\n};\nvar _c;\n$RefreshReg$(_c, \"BubbleMap\");","map":{"version":3,"names":["React","useEffect","useMap","L","hexbin","d3","BubbleMap","data","_s","map","hexbinGenerator","radius","x","d","y","points","feat","coords","console","log","bins","colorScale","scaleLinear","domain","min","HRV","mean","max","range","hexbinLayer","layerGroup","addTo","forEach","bin","avgHRV","find","feature","hexCoords","generateHexagon","polygon","color","fillColor","fillOpacity","weight","hasLayer","removeLayer","_c","lat","lng","angle","Math","PI","i","push","sin","cos","$RefreshReg$"],"sources":["/Users/fmparantean/Desktop/mixvisual 3/src/BubbleMap/index.js"],"sourcesContent":["import React, { useEffect } from 'react';\nimport { useMap } from 'react-leaflet'; // Use Leaflet map context\nimport L from 'leaflet'; // Import Leaflet\nimport { hexbin } from 'd3-hexbin'; // Import D3 hexbin for creating hexagons\nimport * as d3 from 'd3'; // Import D3 utilities\n\nexport const BubbleMap = ({ data }) => {\n    const map = useMap(); // Access the Leaflet map instance\n\n    useEffect(() => {\n        // Create hexbin generator\n        const hexbinGenerator = hexbin()\n            .radius(20) // Radius for the hexbins\n            .x(d => d[0]) // Longitude accessor\n            .y(d => d[1]); // Latitude accessor\n\n        // Prepare points for hexbin\n        const points = data.map(feat => feat.coords); \n\n        // Log the processed points\n        console.log(\"Processed Points:\", points);\n\n        // Generate hexagon bins\n        const bins = hexbinGenerator(points); \n\n        // Log the generated bins\n        console.log(\"Hex Bins:\", bins);\n\n        // Create color scale for HRV values\n        const colorScale = d3.scaleLinear()\n            .domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]) \n            .range(['lightblue', 'blue', 'darkblue']); \n\n        // Create layer group for hexagons\n        const hexbinLayer = L.layerGroup().addTo(map); \n\n        // Create hexagons for each bin\n        bins.forEach(bin => {\n            const avgHRV = d3.mean(bin.map(d => \n                data.find(feature => \n                    feature.coords[0] === d[0] && \n                    feature.coords[1] === d[1]).HRV\n            ));\n\n            // Log average HRV for each bin\n            console.log(\"Average HRV for Bin:\", avgHRV);\n\n            // Generate hexagon vertices\n            const hexCoords = generateHexagon(bin.x, bin.y, 20); // Use the center of the bin\n\n            // Create and add hexagon to the Leaflet map\n            L.polygon(hexCoords, {\n                color: colorScale(avgHRV), // Set color based on average HRV\n                fillColor: colorScale(avgHRV),\n                fillOpacity: 0.6,\n                weight: 1,\n            }).addTo(hexbinLayer); \n        });\n\n        return () => {\n            // Cleanup the hexbin layer on unmount\n            if (map.hasLayer(hexbinLayer)) {\n                map.removeLayer(hexbinLayer);\n            }\n        };\n    }, [data, map]); // Depend on data and map changes\n\n    return null; // No direct rendering\n};\n\n// Function to generate hexagon vertices based on center coordinates and radius\nconst generateHexagon = (lat, lng, radius) => {\n    const angle = (Math.PI / 3); // 60 degrees\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n        points.push([\n            lat + (radius * Math.sin(angle * i)), // Latitude adjustment\n            lng + (radius * Math.cos(angle * i))  // Longitude adjustment\n        ]);\n    }\n    return points; // Return vertices of the hexagon\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}