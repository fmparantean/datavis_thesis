{"ast":null,"code":"var _s = $RefreshSig$();\nimport React from 'react';\nimport { useMap } from 'react-leaflet'; // Import useMap to interact with the Leaflet map\nimport L from 'leaflet'; // Import Leaflet for polygon support\nimport { scaleLinear } from 'd3'; // Import D3 for the color scale\nimport * as d3 from 'd3'; // Import D3 for utility functions\n\nexport const BubbleMap = ({\n  data\n}) => {\n  _s();\n  const map = useMap(); // Grab the Leaflet map instance\n\n  // Create a color scale based on HRV values\n  const colorScale = scaleLinear().domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]).range(['lightblue', 'blue', 'darkblue']); // Set color range\n\n  // Create hexagons for each data point\n  data.forEach(point => {\n    const coords = point.LocationCoordinates;\n\n    // Ensure valid coordinates are being used\n    if (coords && coords.length === 2) {\n      const hexagon = generateHexagon(coords[1], coords[0], 20); // Generate hexagon around the coordinates\n\n      // Add the hexagon shape to the map\n      L.polygon(hexagon, {\n        color: colorScale(point.HRV),\n        fillColor: colorScale(point.HRV),\n        fillOpacity: 0.6,\n        weight: 1\n      }).addTo(map);\n    } else {\n      console.error(\"Invalid coordinates for point:\", point);\n    }\n  });\n  return null; // No direct rendering from this component\n};\n\n// Function to generate hexagon vertices based on a center and radius\n_s(BubbleMap, \"cX187cvZ2hODbkaiLn05gMk1sCM=\", false, function () {\n  return [useMap];\n});\n_c = BubbleMap;\nconst generateHexagon = (lat, lng, radius) => {\n  const angle = Math.PI / 3; // 60 degrees\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    points.push([lat + radius * Math.sin(angle * i),\n    // Latitude adjustment\n    lng + radius * Math.cos(angle * i) // Longitude adjustment\n    ]);\n  }\n  return points; // Returns vertices for hexagon\n};\nvar _c;\n$RefreshReg$(_c, \"BubbleMap\");","map":{"version":3,"names":["React","useMap","L","scaleLinear","d3","BubbleMap","data","_s","map","colorScale","domain","min","d","HRV","mean","max","range","forEach","point","coords","LocationCoordinates","length","hexagon","generateHexagon","polygon","color","fillColor","fillOpacity","weight","addTo","console","error","_c","lat","lng","radius","angle","Math","PI","points","i","push","sin","cos","$RefreshReg$"],"sources":["/Users/fmparantean/Desktop/mixvisual 3/src/BubbleMap/index.js"],"sourcesContent":["import React from 'react';\nimport { useMap } from 'react-leaflet'; // Import useMap to interact with the Leaflet map\nimport L from 'leaflet'; // Import Leaflet for polygon support\nimport { scaleLinear } from 'd3'; // Import D3 for the color scale\nimport * as d3 from 'd3'; // Import D3 for utility functions\n\nexport const BubbleMap = ({ data }) => {\n    const map = useMap(); // Grab the Leaflet map instance\n\n    // Create a color scale based on HRV values\n    const colorScale = scaleLinear()\n        .domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]) \n        .range(['lightblue', 'blue', 'darkblue']); // Set color range\n\n    // Create hexagons for each data point\n    data.forEach(point => {\n        const coords = point.LocationCoordinates;\n\n        // Ensure valid coordinates are being used\n        if (coords && coords.length === 2) {\n            const hexagon = generateHexagon(coords[1], coords[0], 20); // Generate hexagon around the coordinates\n\n            // Add the hexagon shape to the map\n            L.polygon(hexagon, {\n                color: colorScale(point.HRV),\n                fillColor: colorScale(point.HRV),\n                fillOpacity: 0.6,\n                weight: 1\n            }).addTo(map);\n        } else {\n            console.error(\"Invalid coordinates for point:\", point);\n        }\n    });\n\n    return null; // No direct rendering from this component\n};\n\n// Function to generate hexagon vertices based on a center and radius\nconst generateHexagon = (lat, lng, radius) => {\n    const angle = (Math.PI / 3); // 60 degrees\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n        points.push([\n            lat + (radius * Math.sin(angle * i)), // Latitude adjustment\n            lng + (radius * Math.cos(angle * i))  // Longitude adjustment\n        ]);\n    }\n    return points; // Returns vertices for hexagon\n};"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,MAAM,QAAQ,eAAe,CAAC,CAAC;AACxC,OAAOC,CAAC,MAAM,SAAS,CAAC,CAAC;AACzB,SAASC,WAAW,QAAQ,IAAI,CAAC,CAAC;AAClC,OAAO,KAAKC,EAAE,MAAM,IAAI,CAAC,CAAC;;AAE1B,OAAO,MAAMC,SAAS,GAAGA,CAAC;EAAEC;AAAK,CAAC,KAAK;EAAAC,EAAA;EACnC,MAAMC,GAAG,GAAGP,MAAM,CAAC,CAAC,CAAC,CAAC;;EAEtB;EACA,MAAMQ,UAAU,GAAGN,WAAW,CAAC,CAAC,CAC3BO,MAAM,CAAC,CAACN,EAAE,CAACO,GAAG,CAACL,IAAI,EAAEM,CAAC,IAAIA,CAAC,CAACC,GAAG,CAAC,EAAET,EAAE,CAACU,IAAI,CAACR,IAAI,EAAEM,CAAC,IAAIA,CAAC,CAACC,GAAG,CAAC,EAAET,EAAE,CAACW,GAAG,CAACT,IAAI,EAAEM,CAAC,IAAIA,CAAC,CAACC,GAAG,CAAC,CAAC,CAAC,CACvFG,KAAK,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;;EAE/C;EACAV,IAAI,CAACW,OAAO,CAACC,KAAK,IAAI;IAClB,MAAMC,MAAM,GAAGD,KAAK,CAACE,mBAAmB;;IAExC;IACA,IAAID,MAAM,IAAIA,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE;MAC/B,MAAMC,OAAO,GAAGC,eAAe,CAACJ,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;MAE3D;MACAjB,CAAC,CAACsB,OAAO,CAACF,OAAO,EAAE;QACfG,KAAK,EAAEhB,UAAU,CAACS,KAAK,CAACL,GAAG,CAAC;QAC5Ba,SAAS,EAAEjB,UAAU,CAACS,KAAK,CAACL,GAAG,CAAC;QAChCc,WAAW,EAAE,GAAG;QAChBC,MAAM,EAAE;MACZ,CAAC,CAAC,CAACC,KAAK,CAACrB,GAAG,CAAC;IACjB,CAAC,MAAM;MACHsB,OAAO,CAACC,KAAK,CAAC,gCAAgC,EAAEb,KAAK,CAAC;IAC1D;EACJ,CAAC,CAAC;EAEF,OAAO,IAAI,CAAC,CAAC;AACjB,CAAC;;AAED;AAAAX,EAAA,CA/BaF,SAAS;EAAA,QACNJ,MAAM;AAAA;AAAA+B,EAAA,GADT3B,SAAS;AAgCtB,MAAMkB,eAAe,GAAGA,CAACU,GAAG,EAAEC,GAAG,EAAEC,MAAM,KAAK;EAC1C,MAAMC,KAAK,GAAIC,IAAI,CAACC,EAAE,GAAG,CAAE,CAAC,CAAC;EAC7B,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxBD,MAAM,CAACE,IAAI,CAAC,CACRR,GAAG,GAAIE,MAAM,GAAGE,IAAI,CAACK,GAAG,CAACN,KAAK,GAAGI,CAAC,CAAE;IAAE;IACtCN,GAAG,GAAIC,MAAM,GAAGE,IAAI,CAACM,GAAG,CAACP,KAAK,GAAGI,CAAC,CAAE,CAAE;IAAA,CACzC,CAAC;EACN;EACA,OAAOD,MAAM,CAAC,CAAC;AACnB,CAAC;AAAC,IAAAP,EAAA;AAAAY,YAAA,CAAAZ,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}