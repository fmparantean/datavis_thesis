{"ast":null,"code":"var _s = $RefreshSig$();\nimport React from 'react';\nimport { useMap } from 'react-leaflet'; // Use existing Leaflet context\nimport L from 'leaflet'; // Import Leaflet for maps\nimport { scaleLinear } from 'd3'; // For D3 scales\nimport * as d3 from 'd3'; // For data processing\n\nexport const BubbleMap = ({\n  data\n}) => {\n  _s();\n  const map = useMap(); // Use the Leaflet map context\n\n  // Log the data being passed to the BubbleMap\n  console.log(\"Data in BubbleMap:\", data);\n\n  // Prepare color scale for HRV values\n  const colorScale = scaleLinear().domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]) // HRV values\n  .range(['lightblue', 'blue', 'darkblue']); // Color range\n\n  // Log scale values\n  console.log(\"Color scale:\", colorScale.domain());\n\n  // Create hexagons for each data point\n  data.forEach(point => {\n    const coords = point.LocationCoordinates;\n    if (!coords || coords.length < 2) {\n      console.error(\"Missing or invalid coordinates for point:\", point);\n      return; // Skip if coordinates are invalid\n    }\n\n    // Log the coordinates being processed\n    console.log(\"Processing coordinates:\", coords);\n\n    // Create a hexagon shape\n    const hexagon = generateHexagon(coords[1], coords[0], 20); // 20 is the radius\n\n    // Add hexagons to map\n    L.polygon(hexagon, {\n      color: colorScale(point.HRV),\n      // Color based on HRV value\n      fillColor: colorScale(point.HRV),\n      fillOpacity: 0.6,\n      weight: 1\n    }).addTo(map);\n  });\n  return null; // No rendering directly, layers are added to the map\n};\n\n// Generate hexagon based on center coordinates and radius\n_s(BubbleMap, \"cX187cvZ2hODbkaiLn05gMk1sCM=\", false, function () {\n  return [useMap];\n});\n_c = BubbleMap;\nconst generateHexagon = (lat, lng, radius) => {\n  const angle = Math.PI / 3; // 60 degrees\n  const points = [];\n  for (let i = 0; i < 6; i++) {\n    points.push([lat + radius * Math.sin(angle * i),\n    // Latitude modification\n    lng + radius * Math.cos(angle * i) // Longitude modification\n    ]);\n  }\n  return points; // Returns vertices for hexagon\n};\nvar _c;\n$RefreshReg$(_c, \"BubbleMap\");","map":{"version":3,"names":["React","useMap","L","scaleLinear","d3","BubbleMap","data","_s","map","console","log","colorScale","domain","min","d","HRV","mean","max","range","forEach","point","coords","LocationCoordinates","length","error","hexagon","generateHexagon","polygon","color","fillColor","fillOpacity","weight","addTo","_c","lat","lng","radius","angle","Math","PI","points","i","push","sin","cos","$RefreshReg$"],"sources":["/Users/fmparantean/Desktop/mixvisual 3/src/BubbleMap/index.js"],"sourcesContent":["import React from 'react';\nimport { useMap } from 'react-leaflet'; // Use existing Leaflet context\nimport L from 'leaflet'; // Import Leaflet for maps\nimport { scaleLinear } from 'd3'; // For D3 scales\nimport * as d3 from 'd3'; // For data processing\n\nexport const BubbleMap = ({ data }) => {\n    const map = useMap(); // Use the Leaflet map context\n\n    // Log the data being passed to the BubbleMap\n    console.log(\"Data in BubbleMap:\", data);\n\n    // Prepare color scale for HRV values\n    const colorScale = scaleLinear()\n        .domain([d3.min(data, d => d.HRV), d3.mean(data, d => d.HRV), d3.max(data, d => d.HRV)]) // HRV values\n        .range(['lightblue', 'blue', 'darkblue']); // Color range\n\n    // Log scale values\n    console.log(\"Color scale:\", colorScale.domain());\n\n    // Create hexagons for each data point\n    data.forEach(point => {\n        const coords = point.LocationCoordinates;\n\n        if (!coords || coords.length < 2) {\n            console.error(\"Missing or invalid coordinates for point:\", point);\n            return; // Skip if coordinates are invalid\n        }\n\n        // Log the coordinates being processed\n        console.log(\"Processing coordinates:\", coords);\n\n        // Create a hexagon shape\n        const hexagon = generateHexagon(coords[1], coords[0], 20); // 20 is the radius\n\n        // Add hexagons to map\n        L.polygon(hexagon, {\n            color: colorScale(point.HRV), // Color based on HRV value\n            fillColor: colorScale(point.HRV),\n            fillOpacity: 0.6,\n            weight: 1,\n        }).addTo(map);\n    });\n\n    return null; // No rendering directly, layers are added to the map\n};\n\n// Generate hexagon based on center coordinates and radius\nconst generateHexagon = (lat, lng, radius) => {\n    const angle = (Math.PI / 3); // 60 degrees\n    const points = [];\n    for (let i = 0; i < 6; i++) {\n        points.push([\n            lat + (radius * Math.sin(angle * i)), // Latitude modification\n            lng + (radius * Math.cos(angle * i))  // Longitude modification\n        ]);\n    }\n    return points; // Returns vertices for hexagon\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}